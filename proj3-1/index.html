<html>
	<head>
	</head>
	<body>

		<h1>CS184 Project 3-1 - Max Lord and Eugenia Gavrilova</h1>
		<h2>
			Overview
		</h2>
		<p>
			<h3>1. An overview of the project, including your approach to and implementation for each of the parts, as well as what problems you have encountered and how you solved them.</h3>

			<br />
		</p>
		<h2>
			Part 1
		</h2>
		<p>
			<h3>1. Walk through the ray generation and primitive intersection parts of the rendering pipeline.</h3>

			<br />
			<h3>2. Explain the triangle intersection algorithm you implemented in your own words.</h3>

			<br />
			<h3>3. Show images with normal shading for a few small .dae files.</h3>

			<br />


		</p>
		<h2>
			Part 2
		</h2>
		<p>
			<h3>1. Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.</h3>

			<br />
			<h3>2. Show images with normal shading for a few large .dae files that you can only render with BVH acceleration.</h3>

			<br />
			<h3>3. Compare rendering times on a few scenes with moderately complex geometries with and without BVH acceleration. Present your results in a one-paragraph analysis.</h3>

			<br />
		</p>
		<h2>
			Part 3
		</h2>
		<p>
			<h3>1. Walk through both implementations of the direct lighting function.</h3>

			<br />
			<h3>2. Show some images rendered with both implementations of the direct lighting function.</h3>

			<br />
			<h3>3. Focus on one particular scene with at least one area light and compare the noise levels in soft shadows when rendering with 1, 4, 16, and 64 light rays (the -l flag) and with 1 sample per pixel (the -s flag) using light sampling, not uniform hemisphere sampling.</h3>

			<br />
			<h3>4. Compare the results between uniform hemisphere sampling and lighting sampling in a one-paragraph analysis.</h3>

			<br />
		</p>
		<h2>
			Part 4
		</h2>
		<p>
			<h3>
				Walk through your implementation of the indirect lighting function.
			</h3>

			<br />
			<h3>
				2. Show some images rendered with global (direct and indirect) illumination. Use 1024 samples per pixel.
			</h3>

			<br />
			<h3>
				3. Pick one scene and compare rendered views first with only direct illumination, then only indirect illumination. Use 1024 samples per pixel.
			</h3>

			<br />
			<h3>
				4. For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2, 3, and 100 (the -m flag). Use 1024 samples per pixel.
			</h3>

			<br />
			<h3>5. Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.</h3>

			<br />
		</p>
		<h2>
			Part 5
		</h2>
		<p>

			<h3>
			1. Walk through your implementation of the adaptive sampling.
			</h3>

			<br />
			<h3>2. Pick one scene and render it with at least 2048 samples per pixel. Show a good sampling rate image with
				clearly visible differences in sampling rate over various regions and pixels. Include both your sample rate image,
				which shows your how your adaptive sampling changes depending on which part of the image you are rendering, and your noise-free rendered result. Use 1 sample per light and at least 5 for max ray depth.
			</h3>

			<br />

		</p>
		<h2>
			Collaboration
		</h2>
		We split up the project and each partner did specific parts instead of pair programming due to availability.
		We kept in contact regarding our progress so we could continue where the other partner left off.
		<h3>
			Website Link
		</h3>
		<p>
			<a href="https://cal-cs184-student.github.io/sp22-project-webpages-maxqlord/proj3-1/index.html">https://cal-cs184-student.github.io/sp22-project-webpages-maxqlord/proj3-1/index.html</a>
		</p>
	</body>
</html>
