<html>
	<head>
	</head>
	<body>

		<h1>CS184 Project 1 - Max Lord and Eugenia Gavrilova</h1>
		<h2>
			Task 1
		</h2>
		<p>
			<h3>1. Walk through how you rasterize triangles in your own words.</h3>
			First, we define the bounding box of the triangle as the smallest rectangle that completely encloses the triangle.
			For each pixel (x,y) in this bounding box, we check whether the center of the pixel at coordinate (x + .5, y + .5) fulfills the point-in-triangle three-line test,
			which we determine by plugging (x + .5, y + .5) into an equation which will return 0 if the point is on the edge, < 0 if the point is outside the edge, or > 0 if the point is inside the edge.
			If the point is inside the edge (< 0) for all three lines, we determine the point is inside the triangle.  Also, we must factor in winding order,
			which we can consider by also determining the point is in the triangle if the point is "outside the edge" (> 0)
			for all three lines, which can only be the case if the point is in the triangle but has opposite winding order.
			For each pixel, if we have determined it is inside the triangle by our three-line test, we color the pixel with the triangle color, and if not, we don't color the point with the triangle color.
			<br />

			<h3>2. Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.</h3>
			We loop the x pixel from left x bound to right x bound and the y pixel from top y bound to bottom y bound,
			where left x bound is defined as the floor of the minimum of all the x values, so that must bound the left side of the triangle.
			The right x bound is defined as the ceiling of the maximum of all the x values, so that must bound the right side of the triangle.
			The top y bound is defined as the floor of the minimum of all the y values, so that must bound the top of the triangle.
			The bottom y bound is defined as the ceiling of the maximum of all the y values, so that must bound the bottom of the triangle.
			Since we loop between these bounds, no other samples are considered, so it is no worse (and is equal to) one that checks each sample within the bounding box of the triangle.
			<br />
			<h3>3. Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</h3>
			<img src="task1basic4.png" width="50%" />
			<br />
		</p>
		<h3>
			Task 2
		</h3>
		<p>
			1. Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.
			<br />
			2. Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.
			<br />
		</p>
		<h3>
			Task 3
		</h3>
		<p>
			1. reate an updated version of svg/transforms/robot.svg with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your svg file as my_robot.svg in your docs/ directory and show a png screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.
			<br />
		</p>
		<h3>
			Task 4
		</h3>
		<p>
			1. Explain barycentric coordinates in your own words and use an image to aid you in your explanation. One idea is to use a svg file that plots a single triangle with one red, one green, and one blue vertex, which should produce a smoothly blended color triangle.
			<br />
			2. Show a png screenshot of svg/basic/test7.svg with default viewing parameters and sample rate 1. If you make any additional images with color gradients, include them.
			<br />
		</p>
		<h3>
			Task 5
		</h3>
		<p>
			1. Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. Briefly discuss the two different pixel sampling methods, nearest and bilinear.
			<br />
			2. Check out the svg files in the svg/texmap/ directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. Show and compare four png screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.
			<br />
			3. Comment on the relative differences. Discuss when there will be a large difference between the two methods and why.
			<br />
		</p>
		<h3>
			Task 6
		</h3>
		<p>
			1. Explain level sampling in your own words and describe how you implemented it for texture mapping.
			<br />
			2. You can now adjust your sampling technique by selecting pixel sampling, level sampling, or the number of samples per pixel. Describe the tradeoffs between speed, memory usage, and antialiasing power between the three various techniques.
			<br />
			3. Using a png file you find yourself, show us four versions of the image, using the combinations of L_ZERO and P_NEAREST, L_ZERO and P_LINEAR, L_NEAREST and P_NEAREST, as well as L_NEAREST and P_LINEAR.
			<br />
			To use your own png, make a copy of one of the existing svg files in svg/texmap/ (or create your own modelled after one of the provided svg files). Then, near the top of the file, change the texture filename to point to your own png. From there, you can run ./draw and pass in that svg file to render it and then save a screenshot of your results.
			<br />
			Note: Choose a png that showcases the different sampling effects well. You may also want to zoom in/out, use the pixel inspector, etc. to demonstrate the differences.
			<br />
		</p>
		<h3>
			Website Link
		</h3>
		<p>
			<a href="https://cal-cs184-student.github.io/sp22-project-webpages-maxqlord/proj1/index.html">https://cal-cs184-student.github.io/sp22-project-webpages-maxqlord/proj1/index.html</a>
		</p>
	</body>
</html>
